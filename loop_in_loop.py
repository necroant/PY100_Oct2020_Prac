#!/usr/bin/env python
# coding: utf-8

# In[2]:


from random import randint

# In[5]:


"""
Для дальнейшей работы и распечатывания матрицы можно использовать данную функцию
по умолчанию функция работает с числами с двумя знаками, но задав параметр length
можно увеличить ширину столбцов
"""


def print_matrix(matrix, length=3):
    """
    Функция печатает отформатированную матрицу

    Parameters:
    matrix: список списков
    matrix = [[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]]
    length: ширина столбца

    Returns:
        None

    """
    for row in range(len(matrix)):
        for col in range(len(matrix[0])):
            print("{:{}}".format(matrix[row][col], length), end=" ")
        print()


# # # Циклы. Цикл for
#
# # ## Двумерные списки
#
# # ---
# # Двумерная матрица характеризуется двумя параметрами количеством строк и столбцов. Обычно на первом месте указывают строки, а затем столбцы.
# # То есть таблица с размерами **N x M** имеет **N** строк и **M** столбцов.
#
# # Двумерная матрица представляет собой таблицу. Если одномерная матрица это список, то двумерная это список списков.
# # ```python
# # matrix = [[1, 2],
# #           [3, 4],
# #           [5, 6]]
# # ```
# #
# # Видим, что размер данной таблицы **3 х 2**
#
# # Подумайте, как можно найти количество строк и столбцов двумерной матрицы?
#
# # In[12]:
#
#
# matrix = [[1, 2],
#           [3, 4],
#           [5, 6]]
#
# # с помощью функции len найдите длину и ширину матрицы
# N =
# M =
#
# # ### Индексация в двумерной матрице
# # Так как двумерная матрица это список списков, то попробуем сделать свою матрицу
#
# # In[13]:
#
#
# matrix = [[0] * 5] * 5
# matrix
#
# # Видно, что получился список списков, где каждый вложенный список представляется собой строку. Тогда
# чтобы обратиться к отдельному элементу матрицы нужно использовать двойную индексацию
#
# # In[14]:
#
#
# matrix[0][0]
#
# # Отлично, теперь попробуем изменить какой-либо элемент матрицы
#
# # In[15]:
#
#
# matrix[0][0] = 1
# matrix
#
# # Попробуйте объяснить, почему так получилось. Поменяли один элемент, а изменилась вся матрица.
# #
# # ---
# # **Запомните!!!**
# #     Такой способ создания матрицы недопустим `[[0] * 5] * 5`
# #
# # ---
#
# # ### Заполнение матрицы
# # Рассмотрим далее несколько корректных способов заполнения матрицы
#
# # In[31]:
#
#
# # матрица заполненная последовательными числами
# N = 5
# M = 5
# correct_matrix = [[(M * i) + j for j in range(M)] for i in range(N)]
# print_matrix(correct_matrix)
#
# # In[32]:
#
#
# correct_matrix[-1][-1] = 0
# print_matrix(correct_matrix)
#
# # In[33]:
#
#
# # нулевая матрица
# N = 4
# M = 3
# zero_matrix = [[0 for _ in range(M)] for _ in range(N)]
# print_matrix(zero_matrix)
#
# # In[28]:
#
#
# zero_matrix[0][0] = -1
# print_matrix(zero_matrix)
#
# # In[34]:
#
#
# # матрица заполненная случайными целыми числами
# N = 5
# M = 6
# random_matrix = [[randint(1, 9) for _ in range(M)] for _ in range(N)]
# print_matrix(random_matrix)
#
# # ## Работа с вложенными циклами
#
# # Итак для работы над матрицами нам нужны два цикла, которые один вложен в другой.
# # Для того чтобы обойти всю таблицу, нужен один цикл, который будет последовательно перебирать все строки. А второй цикл будет перебирать все столбцы для каждой строки.
# # То есть обход матрицы будет *слева-направо, сверху-вниз*
# #
# # Обычно индекс, который отвечает за строки обозначают как `i`, а за столбцы `j`, тогда:
#
# # In[47]:
#
#
# N = 2
# M = 3
# # заполнили матрицу последовательными числами
# matrix = [[(M * i) + j for j in range(M)] for i in range(N)]
# """
# Матрица после заполнения
# [[0, 1, 2],
#  [3, 4, 5]]
# """
#
# for i in range(N):  # цикл отвечающий за строки
#     for j in range(M):  # цикл отвечающий за столбцы
#         print(matrix[i][j], end=" ")
#
# # Видим, что наша матрица распечата в виде одномерной. Хотя все элементы последовательно расположены друг за другом.
# # Подумайте, куда нужно добавить строку `print()`, которая будет печатать строку матрицы на отдельной строке?
#
# # In[48]:
#
#
# # добавьте одну строку print() так, чтобы матрица была распечатана в виде двумерной
# for i in range(N):  # цикл отвечающий за строки
#     for j in range(M):  # цикл отвечающий за столбцы
#         print(matrix[i][j], end=" ")
#
# # ---
# # В предыдущем примере мы делали обход сначала по строкам, а затем по столбцам. Но ничего не мешает сделать обход сначала по столбцам, а затем по строкам (т.е. сверху-вниз справа-налево).
# # Для этого всего лишь необходимо поменять местами внешний и внутренний цикл:
#
# # In[49]:
#
#
# for j in range(M):  # цикл отвечающий за столбцы
#     for i in range(N):  # цикл отвечающий за строки
#         print(matrix[i][j], end=" ")  # при этом индексация при обращении к матрице не меняется
#     print()
#
# # И получилась такая ситуация, что теперь строка является столбцом исходной матрицы. То есть строки поменялись местами со стобцами. Такая матрица по отношению к исходной называется *транспонированной*.
#
# # ---
# # Попробуем решить несколько задач по работе с матрицами.
# # ```
# # Дан двухмерный массив N×M. Определить среднее арифметическое каждой строки, определить максимум и минимум каждой строки, а также их индексы.
# # ```
#
# # In[6]:
#
#
# N = 5
# M = 6
# random_matrix = [[randint(1, 9) for _ in range(M)] for _ in range(N)]
#
# mean_value_rows = []  # здесь будут храниться средние значения для каждой строки
# min_value_rows = []  # здесь будут храниться минимальные значения для каждой строки
# min_index_rows = []  # здесь будут храниться индексы минимальных значений для каждой строки
# max_value_rows = []  # здесь будут храниться максимальные значения для каждой строки
# max_index_rows = []  # здесь будут храниться индексы максимальных значений для каждой строки
#
# for row in random_matrix:  # здесь мы целиком берем каждую сроку
#     min_index = 0  # в качестве минимального значения возьмем первый элемент строки
#     max_index = 0
#     min_value = row[min_index]  # начальное минимальное значение для каждой строки будет новое
#     max_value = row[max_index]  # для максимального значения тоже самое
#     for index_col, value in enumerate(row):
#         if value < min_value:
#             min_value = value
#             min_index = index_col
#         if value > max_value:
#             max_value = value
#             max_index = index_col
#     min_value_rows.append(min_value)
#     min_index_rows.append(min_index)
#     max_value_rows.append(max_value)
#     max_index_rows.append(max_index)
#
#     mean_value_rows.append(sum(row) / len(row))
#
# print_matrix(random_matrix)
# print(min_value_rows)
# print(min_index_rows)
# print(max_value_rows)
# print(max_index_rows)
# print([round(mean, 2) for mean in mean_value_rows])
#
# # ---
# # Если бы в задаче не просили найти индексы, то можно было бы обойтись одним циклом. В этом вся прелесть
# языка программирования Python
#
# # In[9]:
#
#
# mean_value_rows = []  # здесь будут храниться средние значения для каждой строки
# min_value_rows = []  # здесь будут храниться минимальные значения для каждой строки
# max_value_rows = []  # здесь будут храниться максимальные значения для каждой строки
#
# for row in random_matrix:  # здесь мы целиком берем каждую сроку
#     min_value_rows.append(min(row))  # кладем в конец списка минимальный элемент строки
#     max_value_rows.append(max(row))
#     mean_value_rows.append(round(sum(row) / len(row), 2))
#
# print(min_value_rows)
# print(max_value_rows)
# print(mean_value_rows)
#
# # ---
# # Со столбцами такой фокус не пройдет, потому что слотбцы не представлены отдельными списками. Поэтому
# для работы со столбцами применим только первый способ.
# # Попробуйте теперь сами найти все указаные характеристики для столбцов:
# # ```
# # Дан двухмерный массив N×M. Определить среднее арифметическое каждого столбца, определить максимум и
# минимум каждой столбца, а также их индексы.
# # ```
#
# # In[ ]:
#
#
# # Решение
#
#
# # ---
# # ## Continue
# #
# # Если прошлый раз был рассмотрено ключевое слово `break`, которое дострочно прерывает выполнение цикла,
# # то сейчас рассмотрим ключевое слово `continue`. Если в теле цикла встречается ключевое слово `continue`,
# # то цикл пропускает весь код до конца тела цикла и переходит на следующий шаг.
#
# # Рассмотрим следующую задачу:
# # ```
# # В клетке находятся фазаны и кролики. Известно, что у них 35 голов и 94 ноги. Узнайте число фазанов и число кроликов.
# # ```
# # Количество фазанов и кроликов выражается целым числом, поэтому будем перебирать все возможные комбинации
# # количества кроликов и фазанов, и если их суммарное количество ног равно, указанному в условии, то мы нашли
# # одно из решений.
#
# # In[17]:
#
#
# heads = 35  # количество голов
# legs = 94  # количество ног
#
# for r in range(heads + 1):  # количетво кроликов
#     for ph in range(heads + 1):  # количетво фазанов
#         #  если суммарное количество голов превышено или ног превышено, то переходим на слудующий шаг цикла
#         if (r + ph) > heads or (r * 4 + ph * 2) > legs:
#             continue
#         if (r + ph) == heads and (r * 4 + ph * 2) == legs:
#             print("Количесво кроликов", r)
#             print("Количесво фазанов", ph)
#             print("---")
#
# # In[ ]:
#
#
# # Самостоятельно
# # Дана вещественная квадратная матрица порядка 5. Найти наименьший элемент на побочной диагонали.
# # Дан целочисленный квадратный массив 7×7. Найти строку с наибольшей суммой элементов.
# # Дана квадратная матрица. Доказать, что она является "магическим" квадратом
# magic = [[16, 1, 12, 7],
#          [11, 8, 15, 2],
#          [5, 10, 3, 18],
#          [4, 17, 6, 9]]
#
# # In[6]:
#
#
# print_matrix(magic)
#
# # In[11]:
#
#
# # Самостоятельно
# # Дан двухмерный массив 5×6. Определить среднее арифметическое положительных элементов каждого столбца.
# # В матрице А(4-строки,3-столбца) поменять местами наибольшие элементы в первом и третьем столбцах.
# # Задана квадратная матрица А размером N×N (N<=10),состоящая из действительных чисел. Найти произведение наименьших элементов каждого столбца матрицы
#
#
# # ## Дополнительные задания:
# #
# # * Получить матрицу, которая будет транспонирована данной
#
# # # Домашнее задание
# # * Выполнить обработку элементов квадратной матрицы A, имеющей N строк и N столбцов. Определить произведение элементов, расположенных параллельно побочной диагонали (ближайшие к побочной). Элементы побочной диагонали имеют индексы от [N,0] до [0,N].
# # * Дано число n. Создайте матрицу целых чисел A[n][n], и заполните его по следующему правилу: числа на диагонали, идущей из правого верхнего в левый нижний угол равны 1; числа, стоящие выше этой диагонали, равны 0; числа, стоящие ниже этой диагонали, равны 2.
# # 0 0 0 1
# # 0 0 1 2
# # 0 1 2 2
# # 1 2 2 2
# # * Дано число n и квадратный массив int A[n][n]. Проверьте, является ли массив симметричным относительно главной диагонали матрицы.
# # 0 1 2
# # 1 2 3
# # 2 3 4
#
# # In[ ]:



